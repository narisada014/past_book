N,W = list(map(int, input().split()))

ws = [0]
vs = [0]
# Nはアイテム数
# アイテム数分重さと価値を配列に追加していく
for i in range(N):
    w, v = list(map(int, input().split()))
    ws.append(w)
    vs.append(v)

# 価値の表の初期化を行う
# アイテム * 重さのマトリクスになる
value = []
for i in range(N+1): # 0埋めしているのでN+1
    value.append([-10**18]*(W+1))

# 全ての次元が-1000000000...となっているので[0][0]の初期位置を0で初期化する
value[0][0] = 0
# 1行ずつ
for i in range(1,N+1):
    # 1列ずつ
    for w in range(W+1):
        # iを使用しない場合はマトリクスの一つ上の価値と既存の極小価値との比較を行う
        value[i][w] = max(value[i][w], value[i-1][w])
        # iを使用する場合
        # 列である重さからインデックスiの重さを引いた時に0以上で追加しても問題ない場合
        # w - ws[i]は現在対象としている重さ列から対象アイテムの重さを引いた時の重さを表す。
        # 2次元配列の重さ次元の配列のインデックスにもなっている、つまりそのインデックスの時の価値+現在対象の価値の計算を行うため
        if w - ws[i] >= 0:
            # maxの前者は初期値。後者は選んだパターン
            value[i][w] = max(value[i][w], value[i-1][w-ws[i]] + vs[i])
# アイテムの最終次元の中(全て選ぶ可能性を計算した結果)の最大値が答えとなる
ans = max(value[N])
print(ans)
print(value)
# その時にとりうる最高の可能性を前の計算結果を使用して計算する効率の良いアルゴリズム
# 全探索を行うと計算量でだめになる問題に適用可能
# もし重さの制限量が多く、アイテム数がそれに対して少ない場合は重さの最小化問題として計算する
# その場合計算量がi * vのマトリクスの計算量になるのでこのプログラムより高速に動作する
# https://yottagin.com/?p=1774
# Pythonでの重さ最小化問題